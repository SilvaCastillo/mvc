<strong>Introduktion</strong>
------------------------------
Det första c:et i de sex c:na är Code style, vilket innebär att se till så att koden i sin helhet ser bra ut. I ett större projekt med flera utvecklare kan man bestämma regler för skrivsättet som ska finnas i koden. Det kan vara radlängd, namnstandarden på variabler, ordningen på import, docblocks mm. Dessa bestämda regler hjälper till med att göra koden läsbar och enklare att förstå. De kan även indirekt skapa färre buggar. Med tydlig struktur och namn blir chansen större att man ser felen tidigare.
För att säkerställa att min Code style är så kontinuerlig som möjligt, använder jag mig av dessa verktyg: php-cs-fixer, PHPMD och PHPStan. php-cs-fixer fixar t.ex. indentering, d.v.s. att göra indrag, och mellanslag, medan både PHPMD och PHPStan endast ger varningar som behövde fixas för att följa de bestämda reglerna. PHPMD hjälpte med strukturproblem. Jag upplevde att det ofta varnades för UndefinedVariable, UnusedLocalVariable och CamelCaseClassName. Det tillkom även ElseExpression som varnade att det fanns en onödig if-sats. PHPStan varnade för metoder som anropades, men som inte fanns: null-problem, felaktiga return-typer och typmismatch. Det vanligaste felet som uppkom var typmismatch och felaktig return-typ.

Det andra c:et är Coverage, som är ett mått på hur stor del av källkoden som har tester och används för att bedöma kvaliteten på testerna, och om de täcker tillräckligt av koden. Att ha en hög coverage är viktigt eftersom det ökar chansen att upptäcka buggar tidigt och ger en indikation att delen som testas fungerar som planerat. Samtidigt behöver hög coverage inte alltid betyda att testerna är i hög kvalitet, utan testerna kan vara väldigt ytliga, t.ex. kollar det bara om koden körs, men inte att resultatet blir korrekt. Därför är det viktigt att fokusera på relevanta tester och inte bara på en hög coverage-procent. 
I mitt repo visar Scrutinizer att min totala coverage är 7.9% vilket motsvarar 43 av 544 rader. De procenten kommer från testerna för Card/ som har 100% täckning, medan andra delar som Controller/ och game/ ligger på 0%. Man kan alltså tydligt se att endast en liten del av källkoden har tester.

Det tredje c:et är <strong>[Cyclomati Complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity)</strong>, ett mått på hur många olika exkveringsvägar som finns i en metod eller klass. Detta värde ökar när man använder sig av exekveringsvägar som if, else, for, while eller switch. Ju flera exekveringsvägar en kod har, desto mer komplex blir koden att förstå och testa. En kod med hög komplexitet kan vara svår att läsa, testa och underhålla medan en kod med låg komplexitet är enklare att förstå, lättare att testa och kan vara mer robust. Det beror på att den mäts på en skala där olika intervaller ger indikationer på hur riskabel koden är. Denna skala gjordes av Thomas McCabe, som visar att ett värde mellan 1 och 10 betyder att koden har en låg risk, samt är lätt att förstå. Intervallet 11-20 berättar han, betyder istället att koden är mer komplex, men fortfarande hanterbar. Det krävs flera tester här, jämfört med 1-10. Vid värdena 21-50, berättar McCabe att koden är mycket komplex och riskfylld, då det blir svårt att förstå alla olika exkveringsvägar och att skriva tester som täcker tillräckligt. Om koden överstiger 50 i komplexitet säger McCabe att koden blir extremt komplex, som i praktiken är nästintill omöjlig att testa och lika svår att underhålla.
I min kod visar PhpMetrics i genomsnitt cyclomati complexity på 4.36 per class. Därmed kan jag konstatera att min kod i genomsnitt är relativt enkel att förstå och testa. Dock finns det några klasser som har värden högre än 10 som är markerade i rött, men det är en kombination av hög cyclomati complexity och låg Maintainability index.

Det femte c:et är <strong>[coupling](https://en.wikipedia.org/wiki/Coupling_(computer_programming))</strong> som beskriver hur beroende olika moduler eller klasser är av varandra. Låg coupling innebär förbättrad kodkvalitet därför att det gör systemet enklare att testa, återanvända och underhålla. Hög coupling ökar istället risken att ändringar i en klass kommer påverka andra. Coulpling går oftast hand i hand med cohesion. Det gäller, som tiidigare nämndes, att coupling går ihop med hög cohesion, som leder till en lättare kod att förstå, testa och underhålla. Principen blev introducerad av Larry Consatine under 1960-talet som en del av structure design. Det finns olika nivåer för coupling, från hög till låg. Den mest oönskade nivån är Content coulping, när en module får direkt tillgång till en annan kod och common coupling, som delar moduler globalt. Den mest eftertraktade nivån är Data coulping, där moduler bara delar med sig av enkla och nödvändig data. Hög coupling kan orsaka dominoeffekt när ändringar har gjorts i kod, vilket gör testning och återanvändning svårare, som leder till högra kostnad till underhållning. För en förbättrad kod kvalitet, siktar utvecklare på en låg coupling. Med det menas att modulerna interagerar via klara och väl definierade åtkomstpunkter samt följer information hiding principen. 
För att mäta coupling i mitt system används PhpMetrics. Det mäts med två värden: afferent coupling (AC) och efferent coupling (EC). AC är antalet klasser som påverkar en klass medan EC handlar om antalet klasser som påverkas av en klass. Inom afferent coupling(AC) går värdena från 0 till 3, vilket visar att bra få klasser är beroende av varandra. Efferent coupling (EC) har värden med intervallet 0 till 8, som betyder att de flesta klasser är oberoende av varandra. Samtidigt finns det få controller som är beroende av flera komponenter. Men, överlag är det en låg coupling som indikerar bra modularity, tydlig struktur och lättunderhållen kod.

<strong>[CRAP](https://www.artima.com/weblogs/viewpost.jsp?thread=215899)</strong> är det sjätte c:et, vilket står för Change Risk Analysis and Prediction. Det kombinerar cyclomiatiuc complexity och coverage för att estimera hur riskfylld och svår en del av koden blir att underhålla. Kod med hög komplexitet och låg testtäckning får ett högt CRAP-värde, vilket innebär att det sannolikt kommer finnas buggar och vara svårare att ändra koden. CRAP är baserat på idén att komplex otestad kod oftast är svårast att underhålla och är mer utsatt för fel. CRAP-värdet är beräknat med formeln: CRAP(m) = comp(m)^2 * (1 – cov(m)/100)^3 + comp(m), där CRAP(m) står för cyclomiatiuc complexity, cov(m) är procenten av koden som är coverage via automatiska tester. För att sänka CRAP-värdet, kan utvecklare skapa fler tester för att öka testtäckning eller omstrukturera koden för att reducera komplexitet. 
Min kod har ett genomsnittligt cyclomiatiuc complexity på 4.36 och test coverage är 7.9%, vilket ger ett måttligt CRAP-värde på 19.2. Det föreslår att koden är relativt enkel och enkel att förstå, att ökad coverage ytterligare skulle minska risken för gömda buggar och göra underhåll lättare i framtiden.

<strong>Phpmetrics</strong>
------------------------------
Analysen från PhpMetrics visar flera förbättringsområden: I Maintainbility/Complexity-diagrammet finns flera klasser med cyclomatic complexity 9 till 12, vilket man ser som röda bubblor som indikerar låg maintainbilityindex. Trots det förekommer klasser med en mycket lägre cyclomatic complexity runt 5, som också visas som rött. Samtidigt finns klasser med samma cyclomatic complexity, som är gröna. Detta bevisar att maintainability i PhpMetrics inte bara blir påverkad av cyclomatic complexity utan också av andra faktorer som kodstorlek, antal dependencies som används och struktur i överlag. Majoriteten av efferent coupling-värdena från min kod var mellan 1 och 4, vilket indikerar att de flesta av klasserna har väldigt få dependencies och är därmed stabila. Dock, sticker två klasser ut mer än mängden: LibraryController som har EC på 8 och ApiController som har EC på 6. Detta beror nog på att de är beroende av olika komponenter, vilket förväntas när det gäller controllers som oftast är en koordinator (eller samordnare) mellan olika delar av kod. Det betyder att de är känsligare och skulle tjäna på att omstruktureras eller minska sina dependencies. Enligt Unit Testing-sektionen i PhpMetrics, är 11 av 14 klasser aldrig testade, vilket motsvarar ungefär 79% av koden som saknar automatiska tester. Bland dessa finns LibraryController, ApiController och Game2, med en cyclematic complexity på 10, 12 och 11. Denna relativt höga komplexitet ökar risken för buggar och gör koden svårare att underhålla. Dessa klasser skulle därför ha behövt några tester för att förbättra både stabilitet och underhållbarhet.

<strong>Scrutinizer</strong>
------------------------------
Rapporten från Scrutinizer visar övergripande kodkvalitet och testtäckning i projektet. Min kod fick ett värde på 9.96 / 10, vilket indikerar en ren och välstrukturerad kod. Samtidigt är code coverage endaste 7.9%, vilket betyder att bara en liten del av källkoden är testad. Denna låga testtäckning tyder på att även om strukturen och dokumentationen är bra finns det en hög underhållsrisk när ändringar görs utan ordentlig testning. Flera metoder som GameController::gamePlay() och LibraryController::updateBook(), har ett CRAP-värde på 30. Carp-värdet baseras på både cyclomatic complexity och test coverage för att uppskatta hur svår en metod är att underhålla. Metoderna med höga värden är komplexa och dåligt testade, vilket ökar risken för dolda buggar och framtida underhållningsproblem.

[![Code Coverage](https://scrutinizer-ci.com/g/SilvaCastillo/mvc/badges/coverage.png?b=main)](https://scrutinizer-ci.com/g/SilvaCastillo/mvc/?branch=main) [![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/SilvaCastillo/mvc/badges/quality-score.png?b=main)](https://scrutinizer-ci.com/g/SilvaCastillo/mvc/?branch=main) [![Build Status](https://scrutinizer-ci.com/g/SilvaCastillo/mvc/badges/build.png?b=main)](https://scrutinizer-ci.com/g/SilvaCastillo/mvc/build-status/main)

<strong>Findings</strong>
------------------------------
Rapporten från både Phpmetrics och Scrutinizer visar att flera fynd kan kopplas direkt till 6 c-principen. Coverage är låg (7.9%), vilket indikerar att majoriteten av koden saknar automatiska tester, vilket i sin tur ökar risken för dolda buggar. Cyclomati Complexity-värdena som stiger upp till 12 visar att vissa metoder, som LibraryController och ApiController är mer komplexa och bör omstruktureras för bättre tydlighet. Cohesion-måtten visas genom LCOM-värden i PhpMetrics som generellt starka, vilket betyder att metoderna inom varje klass är väl relaterade. Däremot visar resultatet för Coupling att vissa klasser är starkt beroende av varandra. Det gäller särskilt LibraryController och ApiController, och detta gör dem känsliga för ändringar i koden. CRAP-mätvärderna bekräftar att flera av de komplexa metoderna är otestade och har en hög underhållrisk, då CRAP för vissa metoder ligger runt 30.
Utöver de 6 c:na, ger Maintainability Index (MI) ytterligare insikt i hur enkel koden är att modifiera. Klasser med lågt MI-värde överlappar ofta med de som har hög komplexitet och stark koppling till andra. Dessa mätvärden visar att även om den övergripande kodkvaliteten är hög och strukturerad, bör förbättringar fokusera på att öka testtäckning, förenkla komplexa metoder och minska dependencies mellan tätt sammankopplade klasser.


<strong>Förbättringar</strong>
------------------------------
1. Öka Test Coverage
Jag skapade unit testers för centrala delar av koden, som LibraryController, ApiController och Game21 samt grundläggande tester för andra delar. Jag väljer att förbättra testtäckning då nuvarande coverage är 7.9%, vilket i sin tur skapar hög risk för regressioner och gör refactoring osäker. Att lägga till tester kommer att förbättra pålitlighet och förtroende när man ändrar koden. Jag förväntar mig att testtäckningen kommer att öka från 7.9% till runt 40% under denna korta stund och att CRAP-värdena minskar i metoderna med 30 i värde till 20 eller mindre. Maintainability Index kommer att öka, då det blir en mer modulär och testbar kod som förbättrar underhållbarheten.

2. Minska komplexitet
Metoder med Cyclomatic Complexity mellan 9-12 kan delas upp, med ett passande namn såsom. Den villkorliga logiken kan förenklas genom att minska nested if- och else-satser, samt bryta upp komplexa logiska beslut i mindre, tydliga delar, då hög komplexitet gör kod svårare att läsa, testa och underhålla samt ökar risken för buggar. Jag förväntar mig att Cyclomatic Complexity minskar till under 10, helst mellan 5-8.

3. Minska Coupling mellan klasserna
Efferent coupling kan sänkas i controllerna genom att flytta delar av koden som hanterar validation, filuppladdningar och liknande till separata mindre hjälpklasser. Det innebär att controllerna får mindre kod och färre saker att hantera. LibraryController och ApiController har ett EC-värde på 8 och 6, vilket betyder att de beror på många delar av programmet. Det gör dem svårare att ändra och testa. Genom att dela upp koden i mindre hjälpklasser blir controllerna lättare att förstå och minskar risken att något går sönder när man gör ändringar i koden. Jag förväntar mig att Efferent Coupling kommer att minska från 8 till 6 och 6 till cirka 4, samt att Maintainability Index ökar i värde när koden blir renare och enklare att ändra.


## <strong>Analys efter förbättringar</strong>

<img src="/img/metrics/complexitybefore.png" width="250"/>

Innan refaktorering fanns flera metoder med hög Cyclomatic Complexity och låg maintainability, som visas med stora röda bubblor.

<img src="/img/metrics/complexityafter.png" width="250"/>

Efter att ha genomfört förbättringarna visar Phpmetrics en tydligt positiv förbättring. I jämförelse med det förra diagrammet, har flera cirklar nu ändrat färg från rött till gult eller grönt. Detta visar att klasserna nu är betydligt lättare att förstå, testa och underhålla. 

Cyclomatic complexity har också förändrats på ett tydligt sätt. Innan förbättringarna låg den högsta komplexiteten på 12 och flera andra metoder låg på 11, 10 och 9. Efter förbättringarna är den högsta komplexiteten fortfarande 11, men alla metoder som tidigare låg på 10 och 9 har nu sjunkit till runt 6. Det innebär att majoriteten av koden har blivit avsevärt enklare att förstå, testa och underhålla, även om en metod fortfarande har relativt hög komplexitet.

<img src="/img/metrics/couplingbefore.png" width="1200"/>

Couplingsrapporten i PhpMetrics visar tydligt förändringar efter förbättringarna, särskilt i controll-klasserna.
Före förbättringarna var framför allt två controllers starkt kopplade till många delar: LibraryController: EC = 8 och ApiController: EC = 6. Detta innebär att dessa klasser hade mycket logic och fler beroenden, som gjorde dem svårare att testa och känsliga för kodändringar.

<img src="/img/metrics/couplingafter.png" width="1200"/>

Efter förbättringarna blev det en mer balanserad fördelning av coupling, detta tack vare att logic flyttades till nya service-klasser, t.ex. ImageUploadService, BookService, Game21Service och CardGameService.
Dock blev resultatet olika för de två controllers. För LibraryController minskade EC från 8 till 6, vilket är en tydlig förbättring och visar att klassen är mindre beroende av andra delar av systemet. För ApiController ökade istället EC från 6 till 8, vilket kan bero på att klassen anropar flera små service:ar i stället för att göra allt själv. Detta är inget jag reflekterade över till en början med tanke på att apiController använder sig av olika klasser. Couplingen är högre, men varje beroende är enklare samt mer testbar än tidigare.
Med detta sagt, är ansvaret nu bättre uppdelat och komplexa logic ligger inte längre i några stora controllers. Trots att apiController har mer coupling, är koden mer modulär och tydligare separerad, vilket förbättrar underhållbarheten i praktiken.


<img src="/img/metrics/unittestbefore.png" width="1000"/>

Före förbättringarna visade phpMetrics att 11 av 14 klasser (78,57) aldrig blir anropade av tester. Detta inkluderar viktiga delar av appen som libraryController, ApiController och Game21. Dessutom hade de ett relativt högt komplexitetvärde mellan 9-12. En kombination med komplex och otestad kod ökar risken för dolda buggar och gör det svårare att refaktorera.

<img src="/img/metrics/unittestafter.png" width="950"/>

Efter att ha lagt till alla förbättringar samt att ha gjort nya tester, visar PhpMetrics att en tydlig förbättring har skett. Antalet test suit har ökat från 3 till 6 och antalet assertions har stigit från 16 till 96, även fast antalet klasser som aldrig anropas av tester fortfarande är 11. Det beror på att jag inte gjorde några tester för controllen utan att testerna är till för logiken i service-mappen istället för controller. Därför är mer av appen täckt av tester även fast det inte syns fullt ut i klass-anrop.


<img src="/img/metrics/testbefore.png" width="750"/>

Före förbättringarna låg den totala code coveragen på 7.9%, vilket betyder att nästan hela koden kördes utan automatiska tester.
Efter att jag lade till tester för Book, Bookservice, Game21Service och CardGameService har coverage ökat till 27%. Denna ökning visar att testerna nu faktiskt täcker en betydligt större del av koden jämfört med tidigare.

<img src="/img/metrics/testafter.png" width="400"/>

I Scrutinizers vy för testtäckning per klass syns förbättringen ännu tydligare. Här kan man se att flera klasser nu har mycket hög coverage, varav Game21Service med 80% och BookService med 83%. Även fast inte hela appen har hög testtäckning ännu är de mest kritiska delarna nu väl testade, vilket minskar risken för buggar och gör vidare refaktorering säkrare.
Målet med förbättringen av att “öka test coverage” var för att förändra och utöka koden, utan att riskera att befintlig funktionalitet går sönder. Jämförelsen mellan PhpMetrics och Scrutinizer före och efter förbättringarna visar att målet har uppnåtts, även fast den totala testtäckningen fortfarande är relativt låg med 27%. 
I och med detta förväntar jag mig att CRAP-värdena för de komplexa metoderna har sjunkit, eftersom CRAP beror både på cyclomatic complexity och test coverage. När testtäckningen ökar och komplexiteten sjunker blir koden mer stabil och lättare att underhålla.


<strong>Diskussion</strong>
------------------------------

Jag tycker att man kan arbeta aktivt med kodkvalitet och clean code på det sätt som vi gjort i uppgiften. Det tog tid att komma in i processen, men när man väl förstod hur verktygen fungerar blev det tydligare hur mycket de kan bidra med för en förbättrad kodstruktur.
Det finns flera fördelar med att arbeta på detta sätt: Kod som följer clean code-principen blir enklare att läsa, lättare att felsöka och mer stabila när man bygger ut eller ändrar dem; Det gör även testning mer effektivt eftersom tydligare logic är lättare att skriva test för.
Det finns även vissa nackdelar: Det tar extra tid att arbeta med strukturen genom mätverktygen, tester och refaktorering, särskilt i början när man lär sig verktygen; För små projekt kan det ibland kännas som merarbete när man är ensam, men på längre sikt sparar de både tid och arbete eftersom koden blir mer robust och mindre känslig för fel.
Det finns även andra sätt att arbeta mot clean code, t.ex. genom att införa code reviews, använda linters ofta och skriva tester samtidigt som man utvecklar. Allt detta kan bidra till att hålla koden ren och lätt att underhålla.
