<a id="kmom01"></a>Kmom01
------------------------------

Jag har tidigare gått OOPython-kursen och har därigenom fått grundläggande erfarenhet av att arbeta med klasser och objekt i Python. 
En klass är en mall eller ett recept för att skapa objekt. Där den beskriver vilka metoder och egenskaper objekten ska ha. Ett objekt är en instans av en klass, när man har definierat en klass så kan man skapa ett objekt utifrån det. För att kunna skapa klasser är det också viktigt att förstå hur konstruktorn fungerar, då den kan användas för att skapa  objektens egenskaper. 
Efter att ha gjort övningen tyckte jag att det var lätt att förstå kodstrukturen i Symfony. Det var enkelt att hitta var man skulle lägga till kod, och mapparna var logiskt uppdelade, vilket gjorde det smidigt att navigera i projektet. Några saker som jag tycker är värdefulla är PSR (PHP standards Recommendations), som är standarden för hur man bör strukturera sin kod, till exempel namnkonventioner och kodstil. Jag uppskattar också Security Best Practices, där det handlar om hur man skyddar sig mot SQL-injektioner och hanterar lösenord med hashning på ett säkert sätt. Såklart är även andra delar som nämns viktigt, som Error handling, Database access med PDO men för mig är just  PSR och säkerhetsaspekterna som känns allra viktigast.


<a id="kmom02"></a>Kmom02
------------------------------

Arv är när en subklass ärver egenskaper och metoder från en annan klass. Komposition innebär att en klass använder andra objekt istället för att ärva från dem. Det innebär att koden blir mer flexibel. Interface definierar vilka metoder en klass måste implementera, men ger inte själva implementationen. Det används för att säkerställa att olika klasser följer en viss struktur. Traits används för att dela metoder mellan klasser utan arv. Det är praktiskt när flera klasser ska återanvända samma kod, men inte kan ärva samma bas.

Jag började med att skapa Card-klassen. Jag gjorde ett misstag då jag av misstag byggde en hel kortlek i den, istället för ett enskilt kort. Jag upptäckte det efter att jag redan hade implementerat flera funktioner. Dessa implementeringar flyttade jag sedan över till DeckOfCards-klassen, och lade in de korrekta funktionerna i Card. Card-klassen anropades därefter i createDeck() i DeckOfCards.

Jag kontrollerade att allt fungerade som det skulle. Det gällde att jag kunde visa korrekt kortleksdata på sidan inklusive att shuffle-funktionen fungerade, d.v.s. att hela leken gick att se och att det gick att dra ett eller flera kort. Därefter gick jag vidare och skapade CardGraphic-klassen. Den gav varje kort rätt symbol (♥, ♦, etc). Därefter arbetade jag med CSS för att ge korten en enklare men tydlig design.

Jag blev särskilt nöjd med hur jag implementerade draw()-funktionen. Jag planerade från början att den skulle kunna hantera både att dra ett enda kort och flera kort, utan att behöva duplicera kod. Jag lade även till en kontroll som kollar om användaren försöker dra fler kort än vad som finns kvar i leken. I så fall returneras null istället för att dra några kort alls. Jag hade samma tanke när jag gjorde mina template-filer. Jag ville ha en gemensam vy för både enkel och flera dragningar, och samma sak gäller för deck och shuffle. Det gav bättre struktur i projektet.

Det jag är medveten om kan förbättras i koden är hanteringen av kort, d.v.s. när användaren försöker dra för många kort. Idag returneras bara null och användaren skickas tillbaka till deck-vyn. Jag hade hellre velat att systemet drog så många kort som möjligt (till ett max-antal) om användaren försöker dra fler än vad som finns kvar.

Jag tycker att det går bra. Symfony är inte så svårt att få ett grepp om. Jag kollar mycket på exempel-koden vi får och söker upp om det är något jag undrar över. Dessutom har det gått bra att programmera OOP. Jag råkade göra fel i card-class genom att jag först byggde hela deckofcards där, men skapade senare en egen klass för det.

<a id="kmom03"></a>Kmom03
------------------------------

Jag tycker att det kändes bra att arbeta med flödesdiagram eftersom det hjälpte mig att få en tydlig överblick över hur spelet skulle fungera. Pseudokoden kändes lite onödig för mig, men det kan bero på att jag gjorde flödesdiagrammet först. Jag kan tänka mig att pseudokoden kan vara mer användbar om man börjar med den innan man gör flödesdiagrammet. Det kan hjälpa till att strukturera tankarna tidigt i processen. Överlag tror jag att båda metoderna kan stödja problemlösning och hjälpa till att planera koden mer effektivt.

Jag löste uppgiften genom att använda sessions för att spara spelets status, d.v.s. vilka kort som dragits för spelare och bank, om det är spelarens tur, om spelet har börjat och poäng för varje sida. Till en början lade jag logiken i controllern, men det blev snabbt för mycket kod. Jag valde då att bryta ut logiken till en separat klass, Game21. Det gjorde koden mer strukturerad och lättläst.
I Game21-klassen använde jag sessions direkt i konstruktorn, vilket gör det enkelt att hantera spelets tillstånd inom klassen. Jag har även försökt undvika upprepning i koden, till exempel genom att låta funktionen drawCardForPlayer() ta ett argument som avgör om det är spelaren eller banken som ska få ett kort. Då blir funktionen flexibel och återanvändbar.
En möjlig förbättring med min uppgift hade varit att skapa en separat klass som representerar spelet som ett objekt, med all speldata samlad där. Men i det här fallet såg jag inte någon tydlig fördel med det. Ytterligare förbättringar skulle kunna göras genom att flytta fler kontrollstrukturer från controllern till egna metoder för att minska kodens komplexitet.

Överlag är jag nöjd med min lösning, särskilt hur jag lyckades strukturera om koden för bättre läsbarhet och återanvändbarhet.

Det känns bra att arbeta med Symfony. Jag trodde att det skulle bli svårare, men det har gått bra. Det var relativt lätt att sätta mig in i ramverket utan några större problem, och det finns rätt mycket dokumentation på nätet att ta hjälp av om man kör fast.

Jag lärde mig vad pseudokod är som jag tror att jag inte hade hört talas om tidigare. Som jag nämnde tidigare kändes det lite onödigt att använda det i mitt fall, eftersom jag redan hade gjort ett flödesdiagram. Dock förstår jag att pseudokod kan vara ett bra komplement, helst om man använder det innan man gör ett flödesdiagram.

<a id="kmom04"></a>Kmom04
------------------------------

Inledningsvis upplevde jag det som lagom svårt att skriva kod som testar annan kod med PHPUnit. Jag har tidigare skrivit tester i Python och tycker att PHPUnit påminner en del om det och därför var det naturligt att använda PHPUnit. Kodtäckningen för klasserna Card, CardGraphic och DeckOfCards blev 100%, så jag lyckades väldigt bra med kodtäckningen av min kod. Jag använde mig också av testprinciper såsom att bara testa en sak i taget, vilket ledde till fler, men tydligare, tester jämfört med att slå ihop flera tester i ett test.
Vidare tycker jag att det mesta av min kod är testbart, men controller-klasserna var svårare att testa, särskilt spel-controllern. Jag funderade ett tag på hur jag kunde förbättra testbarheten där, men hittade ingen bra lösning. Jag valde att inte skriva om någon kod i denna uppgift då det inte behövdes. Det beror på att jag redan till en början kunde skriva tester för Card, CardGraphic och DeckOfCards. Om jag skulle fokusera mer på controller-klasserna skulle jag nog behöva skriva om vissa delar för att göra dem mer testbara. Det är inget jag har gjort i nuläget.
Utöver testbarheten i sig, anser jag att snygg och ren kod ofta är testbar, men testbar kod är inte alltid snygg och ren. Det är alltså möjligt att skriva testbar kod som ändå är rörig, men det ena hänger ofta ihop med det andra.



<a id="kmom05"></a>Kmom05
------------------------------
Det gick bra, trodde att det skulle vara svårare än vad det var men det var väldigt lätt att följa instruktionerna, Doctrine verkade komplext först men med tydliga steg blev det smidigt, och att vi inte skulle göra något avancerat gjorde det att var enkelt att förstå.

Jag ville att böckerna skulle visas som kort (cards) i biblioteket, där man ser omslagsbild, titel och författare. Korten är klickbara och när man klickar på en bok kommer man till en sida med bokinformation. Där visas samma uppgifter som tidigare plus ISBN samt en knapp för att redigera.
På redigeringssidan behåller jag samma layout som på enkelvisningen, men texterna är ersatta av inmatningsfält som kan ändras. Längst ner finns två knappar, en för att spara ändringar (POST) och en för att radera boken från databasen. Raderingsknappen ligger tillsammans med redigeringsknappen men är röd för tydlighet. Det finns även ett kryss uppe till höger för att avbryta redigeringen. Samma knapp finns på visningssidan och tar användaren tillbaka till biblioteket.
För att lägga till böcker gjorde jag ett formulär med alla nödvändiga fält. Jag lade också till filuppladdning för omslag (accepterar PNG och JPG). I visningssidorna finns en kontroll som visar en platshållarbild om boken saknar omslag.

Det fungerade bra att använda ORM för CRUD. Att skapa och uppdatera databasen var väldigt smidigt med migrations och entiteter. Det här är nog första gången jag använder ett ORM. Att använda ORM mot en relationsdatabas gör arbetet enklare, både för att förstå och integrera i koden.
Jämfört med att skriva rå SQL, upplevde jag att ett ORM gav snabbare utveckling, mindre upprepad kod (t.ex. anslutning mot DB och återkommande INSERT/UPDATE/SELECT) samt ett enklare migrationsflöde. Samtidigt kan ORM ha en inlärningskurva och göra det svårare att se exakt vad som händer när databasen och koden växer, vilket ibland gör det svårare att felsöka. I större och mer komplexa databaser kan rå SQL därför ibland vara mer träffsäkert för specifika, avancerade frågor.

Min uppfattning om ORM är att det förenklar och snabbar upp utvecklingen, särskilt för CRUD och migrationer. Man slipper skriva repetitiv kod för databasanslutning och grundläggande queries, exempelvis att det finns standardfunktioner för att hämta viss data från databasen. Men, jag känner att om SQL-queries görs manuellt så har man lite bättre koll på allt. Jag hade nog ändå valt ORM om jag skulle göra en egen app med SQL som databas.

TIL för detta kmom var ORM och hur man använder sig av det. Jag lärde mig även att använda instanceof UploadedFile som bara blir true om något har blivit uppladdat, och hur man använder sig av ValidatorInterface i Symfony. Det tog tid att få grepp om det hela, men jag känner mig fortfarande osäker, särskilt vad gäller getMimeType() som jag använde för att spara ner filen lokalt i rätt format.

<a id="kmom06"></a>Kmom06
------------------------------


<a id="kmom07/10"></a>Kmom07/10
------------------------------